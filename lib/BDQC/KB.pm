package BDQC::KB;

###############################################################################
# Class       : BDQC::KB
#
# Description : This class is autogenerated via OOAPI and is..
#
###############################################################################

use strict;
use warnings;

use BDQC::Response qw(processParameters);

my $CLASS = 'BDQC::KB';
my $DEBUG = 0;
my $VERBOSE = 0;
my $TESTONLY = 0;

my $VERSION = '0.0.1';


sub new {
###############################################################################
# Constructor
###############################################################################
  my $METHOD = 'new';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift;
  my %parameters = @_;
  my $class = ref($self) || $self;

  #### Create the object with any default attributes
  $self = {
  };
  bless $self => $class;

  #### Initialize class variables the first time the class is used
  # none

  #### Process constructor argument class variables
  # none

  #### Process constructor object parameters
  my $dataDirectory = processParameters( name=>'dataDirectory', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD );
  $self->{_dataDirectory} = $dataDirectory;
  my $isChanged = processParameters( name=>'isChanged', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD );
  $self->{_isChanged} = $isChanged;
  my $kbRootPath = processParameters( name=>'kbRootPath', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD );
  $self->{_kbRootPath} = $kbRootPath;
  my $qckb = processParameters( name=>'qckb', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD );
  $self->{_qckb} = $qckb;

  #### Complain about any unexpected parameters
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return($self);
}


sub getDataDirectory {
###############################################################################
# getDataDirectory
###############################################################################
  my $METHOD = 'getDataDirectory';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");

  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return($self->{_dataDirectory});
}


sub setDataDirectory {
###############################################################################
# setDataDirectory
###############################################################################
  my $METHOD = 'setDataDirectory';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");
  my $value = shift;


  $self->{_dataDirectory} = $value;
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return 1;
}


sub getIsChanged {
###############################################################################
# getIsChanged
###############################################################################
  my $METHOD = 'getIsChanged';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");

  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return($self->{_isChanged});
}


sub setIsChanged {
###############################################################################
# setIsChanged
###############################################################################
  my $METHOD = 'setIsChanged';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");
  my $value = shift;

  #### Ensure that the value is of type int32
  unless ( $value =~ /^s*[\-\+]*\d+\s*$/ ) {
    print "ERROR: Unable to set isChanged to '$value': not valid int32\n";
  }


  $self->{_isChanged} = $value;
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return 1;
}


sub getKbRootPath {
###############################################################################
# getKbRootPath
###############################################################################
  my $METHOD = 'getKbRootPath';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");

  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return($self->{_kbRootPath});
}


sub setKbRootPath {
###############################################################################
# setKbRootPath
###############################################################################
  my $METHOD = 'setKbRootPath';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");
  my $value = shift;


  $self->{_kbRootPath} = $value;
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return 1;
}


sub getQckb {
###############################################################################
# getQckb
###############################################################################
  my $METHOD = 'getQckb';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");

  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return($self->{_qckb});
}


sub setQckb {
###############################################################################
# setQckb
###############################################################################
  my $METHOD = 'setQckb';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");
  my $value = shift;


  $self->{_qckb} = $value;
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return 1;
}


sub calcModels {
###############################################################################
# calcModels
###############################################################################
  my $METHOD = 'calcModels';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  $response->logEvent( level=>'INFO', minimumVerbosity=>0, verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
    message=>"Calculating models for all available signatures");

  my $qckb = $self->getQckb();
  $self->setIsChanged(1);
  use BDQC::VectorModel;
  use BDQC::HistogramModel;

  #### For each fileType, signature, and attribute, build a model of the observed data
  foreach my $fileType ( keys(%{$qckb->{fileTypes}}) ) {
    foreach my $signature ( keys(%{$qckb->{fileTypes}->{$fileType}->{signatures}}) ) {
      foreach my $attribute ( keys(%{$qckb->{fileTypes}->{$fileType}->{signatures}->{$signature}}) ) {
        my $values = $qckb->{fileTypes}->{$fileType}->{signatures}->{$signature}->{$attribute}->{values};
        my $model;
        if ( ref($values->[0]) eq 'HASH' ) {
          $model = BDQC::HistogramModel->new( histograms=>$values );
        } else {
         #print "$signature.$attribute: ".join(",",@{$values})."\n";
          $model = BDQC::VectorModel->new( vector=>$values );
        }
        my $result = $model->create();
        if ( $result->{status} eq 'OK' ) {
          $qckb->{fileTypes}->{$fileType}->{signatures}->{$signature}->{$attribute}->{model} = $result->{model};
        } else {
          $response->mergeResponse( responseToMerge=>$result );
        }
      }
    }
  }

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub calcSignatures {
###############################################################################
# calcSignatures
###############################################################################
  my $METHOD = 'calcSignatures';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  $response->logEvent( level=>'INFO', minimumVerbosity=>0, verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
    message=>"Calculating signatures for all new files");

  my $qckb = $self->getQckb();
  $self->setIsChanged(1);

  use BDQC::FileSignature::Text;
  use BDQC::FileSignature::Binary;
  use BDQC::FileSignature::XML;
  use BDQC::FileSignature::Tabular;
  use Time::HiRes qw(gettimeofday tv_interval);

  my %knownExtensions = (
    "tsv" => { specificTypeName=>'tsv', genericType=>'tabular', signatureList=>[ "FileSignature::Tabular" ] },
    "fasta" => { specificTypeName=>'FASTA', genericType=>'text', signatureList=>[ "FileSignature::Text" ] },
    "qlog" => { specificTypeName=>'qlog', genericType=>'text', signatureList=>[ "FileSignature::Text" ] },
    "txt" => { specificTypeName=>'txt', genericType=>'txt', signatureList=>[ "FileSignature::Text" ] },
    "xml" => { specificTypeName=>'xml', genericType=>'xml', signatureList=>[ "FileSignature::XML", "FileSignature::Text" ] },
    "mzML" => { specificTypeName=>'xml', genericType=>'xml', signatureList=>[ "FileSignature::XML", "FileSignature::Text" ] },
    "jpg" => { specificTypeName=>'jpg', genericType=>'image', signatureList=>[ "FileSignature::Binary" ] },
    "jpeg" => { specificTypeName=>'jpg', genericType=>'image', signatureList=>[ "FileSignature::Binary" ] },
    "JPG" => { specificTypeName=>'jpg', genericType=>'image', signatureList=>[ "FileSignature::Binary" ] },
    "JPEG" => { specificTypeName=>'jpg', genericType=>'image', signatureList=>[ "FileSignature::Binary" ] },
    "raw" => { specificTypeName=>'raw', genericType=>'binary', signatureList=>[ "FileSignature::Binary" ] },
    "RAW" => { specificTypeName=>'raw', genericType=>'binary', signatureList=>[ "FileSignature::Binary" ] },
  );

  eval {
    require XML::Parser;
  };
  if ( $@ ) {
    print STDERR "XML::Parser not found, reverting to TXT analysis only\n";
    $knownExtensions{xml}->{signatureList} = [ "FileSignature::Text" ];
    $knownExtensions{mzML}->{signatureList} = [ "FileSignature::Text" ];
  }

  my $nFiles = 0;

  foreach my $fileTag ( keys(%{$qckb->{files}}) ) {
    $nFiles++;
    my $signatures = $qckb->{files}->{$fileTag}->{signatures};
    my $filePath = $signatures->{tracking}->{filePath};
    if ( $signatures->{extrinsic}->{isCompressed} ) {
      $filePath = "zcat $filePath |";   #FIXME
    }
    my $knownExtension = $knownExtensions{$signatures->{extrinsic}->{uncompressedExtension}};
    my $signatureList;
    my $fileTypeName = $signatures->{extrinsic}->{uncompressedExtension};
    if ( $knownExtension ) {
      $signatureList = $knownExtension->{signatureList};
      $fileTypeName = $knownExtension->{specificTypeName};
    } else {
      #$signatureList = [ 'FileSignature::UnknownFiletype' ];
      $signatureList = [ 'FileSignature::Text' ];
    }
    $signatures->{fileType}->{typeName} = $fileTypeName;

    foreach my $signatureName ( @{$signatureList} ) {
      my $moduleName = "BDQC::$signatureName";
      my $signature = $moduleName->new( filePath=>$filePath );
      #my $t0 = [gettimeofday];
      my $result = $signature->calcSignature();
      #my $t1 = [gettimeofday];
      #my $elapsed = tv_interval($t0,$t1);
      #print "$fileTag  $elapsed\n";
      if ( $result->{status} eq 'OK' ) {
        $signatures->{$signatureName} = $result->{signature};
      } else {
        $response->mergeResponse( sourceResponse=>$result );
        return $response;
      }
    }

  }

  $response->logEvent( level=>'INFO', minimumVerbosity=>0, message=>"Calculated signatures for $nFiles files", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub collateData {
###############################################################################
# collateData
###############################################################################
  my $METHOD = 'collateData';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  $response->logEvent( level=>'INFO', minimumVerbosity=>0, verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
    message=>"Collating all data from signatures into a matrix");

  my $qckb = $self->getQckb();
  $self->setIsChanged(1);

  my $nFiles = 0;

  #### First scan through all the files and assign them to a fileType. Models will be built within fileTypes
  foreach my $fileTag ( keys(%{$qckb->{files}}) ) {
    $nFiles++;
    my $signatures = $qckb->{files}->{$fileTag}->{signatures};
    my $fileTypeName = $signatures->{fileType}->{typeName};

    unless ( $qckb->{fileTypes}->{$fileTypeName} ) {
      $qckb->{fileTypes}->{$fileTypeName} = { name=>$fileTypeName, fileTagList=>[], signatures=>{} };
    }

    if ( $signatures->{tracking}->{isNew} ) {
      push(@{$qckb->{fileTypes}->{$fileTypeName}->{fileTagList}},$fileTag);
    }
  }

  #### For each fileType, extract all the signatures for which we'll make a model
  foreach my $fileType ( keys(%{$qckb->{fileTypes}}) ) {
    my $signatures = $qckb->{fileTypes}->{$fileType}->{signatures};
    foreach my $fileTag ( @{$qckb->{fileTypes}->{$fileType}->{fileTagList}} ) {
      foreach my $signature ( keys(%{$qckb->{files}->{$fileTag}->{signatures}}) ) {
        foreach my $attribute ( keys(%{$qckb->{files}->{$fileTag}->{signatures}->{$signature}}) ) {
          unless ( $signatures->{$signature}->{$attribute}->{values} ) {
            $signatures->{$signature}->{$attribute}->{values} = [];
          }
          push(@{$signatures->{$signature}->{$attribute}->{values}},$qckb->{files}->{$fileTag}->{signatures}->{$signature}->{$attribute});
        }
      }
    }
  }

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub createKb {
###############################################################################
# createKb
###############################################################################
  my $METHOD = 'createKb';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  $response->logEvent( level=>'INFO', minimumVerbosity=>1, message=>"Creating new BDQC KB for storing results", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );

  #### Create the qckb data structure and fill it with basic information
  my $qckb = {};
  $self->setQckb($qckb);
  $qckb->{type} = "BDQC";
  $self->setIsChanged(1);

  my ($sec,$min,$hour,$mday,$mon,$year) = localtime();
  $qckb->{startDate} = sprintf("%d-%d-%d %d:%d:%d",1900+$year,$mon+1,$mday,$hour,$min,$sec);

  #### Empty array for updates
  $qckb->{updates} = [];
  $qckb->{changeLog} = [];
  $qckb->{dataDirectories} = [];

  $qckb->{files} = {};
  $qckb->{fileTypes} = {};
  $qckb->{models} = [];

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub getOutliers {
###############################################################################
# getOutliers
###############################################################################
  my $METHOD = 'getOutliers';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  $response->logEvent( level=>'INFO', minimumVerbosity=>0, verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
    message=>"Listing outliers in the BDQC KB");

  my $qckb = $self->getQckb();
  my $outliers;

  #### For each fileType, signature, and attribute, record if any deviations are outliers
  foreach my $fileType ( keys(%{$qckb->{fileTypes}}) ) {
    $outliers->{fileTypes}->{$fileType}->{nFiles} = 0;

    #### First, get the list of fileTagNames for this fileType
    my $fileTagNames = $qckb->{fileTypes}->{$fileType}->{fileTagList};

    #### Loop over the signatures and attributes
    foreach my $signature ( keys(%{$qckb->{fileTypes}->{$fileType}->{signatures}}) ) {
      foreach my $attribute ( keys(%{$qckb->{fileTypes}->{$fileType}->{signatures}->{$signature}}) ) {

        #print "$signature.$attribute:\n";
        my $model = $qckb->{fileTypes}->{$fileType}->{signatures}->{$signature}->{$attribute}->{model};

        #### Loop over all the deviations, looking for one labeled an outlier
        my $iDeviation = 0;
        foreach my $deviation ( @{$model->{deviations}} ) {
          if ( defined($deviation->{deviationFlag}) && $deviation->{deviationFlag} eq 'outlier' ) {

            #### Extract the datum and vaue for the outlier and condition a bit
            my $value = '(null)';
            my $datum = '(null)';
            $value = $deviation->{value} if ( defined($deviation->{value}) );
            $datum = $deviation->{datum} if ( defined($deviation->{datum}) );
            my $tmpText = "'$datum'";
            $tmpText .= " (with value $value)" if ( $datum ne $value );
            #print "  Datum $tmpText is an outlier with a deviation of '$deviation->{deviation}'\n";

            #### Store the information about this outlier
            my $fileTagName = $fileTagNames->[$iDeviation];
            my $outlierData = { signature=>$signature, attribute=>$attribute, datum=>$datum, value=>$value, deviation=>$deviation };
            push( @{$outliers->{fileTypes}->{$fileType}->{fileTags}->{$fileTagName}}, $outlierData );
            $outliers->{fileTypes}->{$fileType}->{nFiles}++;
          }
          $iDeviation++;
        } # end foreach deviation

      } # end foreach attribute

    } # end foreach signature

  } # end foreach fileType


  #### Print out the outlier files and their outlier values
  foreach my $fileType ( sort keys(%{$outliers->{fileTypes}}) ) {
    foreach my $outlierFileTagName ( sort keys(%{$outliers->{fileTypes}->{$fileType}->{fileTags}}) ) {
      print "$outlierFileTagName is an outlier because:\n";
      my $outlierFileTagList = $outliers->{fileTypes}->{$fileType}->{fileTags}->{$outlierFileTagName};
      foreach my $outlier ( @{$outlierFileTagList} ) {
        my $signature = $outlier->{signature};
        my $attribute = $outlier->{attribute};
        my $value = $outlier->{value};
        my $deviation = $outlier->{deviation}->{deviation};
        $value = '(null)' if ( ! defined($value) );
        $value = substr($value,0,70)."...." if ( length($value)>74 );
        print "  $signature.$attribute: Value '$value' is an outlier at $deviation times SIQR\n";
      }
    }
  }

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub importSignatures {
###############################################################################
# importSignatures
###############################################################################
  my $METHOD = 'importSignatures';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  my $inputFile = processParameters( name=>'inputFile', required=>1, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;

  #### If the file exists, read it
  if ( -e $inputFile ) {
    $response->logEvent( level=>'INFO', minimumVerbosity=>0, verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
      message=>"Importing BDQC data into KB from '$inputFile'");
    my $qckb =  $self->getQckb();

    if ( $inputFile =~ /\.gz$/ ) {
      $inputFile = "zcat $inputFile |";
    }

    if ( open(INFILE,$inputFile) ) {
      my $jsonData = '';
      while ( my $line = <INFILE> ) {
        $jsonData .= $line;
      }
      close(INFILE);
      my $inputBdqc = decode_json($jsonData);
      my $iFile = 0;
      foreach my $file ( keys(%{$inputBdqc}) ) {
        my $tmp = {};
        my $components = $self->splitFilePath($file);
        my $fileTag = "import1:$file";
	    my $tracking = { fileTag=>$fileTag, filePath=>$file, filename=>$components->{filename},
          dataDirectory=>$components->{directory}, dataDirectoryId=>'import1', isNew=>1 };
        $tmp->{tracking} = $tracking;

        $tmp->{extrinsic}->{mtime} = $inputBdqc->{$file}->{"bdqc.builtin.extrinsic"}->{mtime};
        $tmp->{extrinsic}->{size} = $inputBdqc->{$file}->{"bdqc.builtin.extrinsic"}->{size};
        $tmp->{extrinsic}->{extension} = $components->{extension};
        $tmp->{extrinsic}->{uncompressedExtension} = $components->{uncompressedExtension};
        $tmp->{extrinsic}->{isCompressed} = $components->{isCompressed};
        $tmp->{extrinsic}->{filename} = $components->{filename};
        $tmp->{extrinsic}->{basename} = $components->{basename};
        $tmp->{extrinsic}->{readable} = $inputBdqc->{$file}->{"bdqc.builtin.extrinsic"}->{readable};
        $tmp->{fileType}->{typeName} = $components->{uncompressedExtension};

        if ( $inputBdqc->{$file}->{"bdqc.builtin.tabular"} ) {
          my $tabular = $inputBdqc->{$file}->{"bdqc.builtin.tabular"};
          $tmp->{tabular}->{"character_histogram"} = $tabular->{"character_histogram"};
          foreach my $attribute ( keys(%{$tabular->{tabledata}}) ) {
            my $value = $tabular->{tabledata}->{$attribute};
            if ( ref($value) eq 'HASH' ) {
              print "$attribute is a HASH\n";
            } elsif ( ref($value) eq 'ARRAY' ) {
              if ( $attribute eq 'columns' ) {
                my $iColumn = 0;
                foreach my $column ( @{$tabular->{tabledata}->{$attribute}} ) {
                  foreach my $columnAttributeName ( keys(%{$column}) ) {
                    my $columnAttributeValue = $column->{$columnAttributeName};
                    if ( ref($columnAttributeValue) eq 'ARRAY' ) {
                      #$columnAttributeValue = join(",",@{$columnAttributeValue});
                      $columnAttributeValue = "TemporarilySuppressed";              # FIXME
                    } elsif ( ref($columnAttributeValue) eq 'HASH' ) {
                      # leave as is
                    } elsif ( ref($columnAttributeValue) eq '' ) {
                      # leave as is
                    }
                    $tmp->{tabular}->{"column$iColumn.$columnAttributeName"} = $columnAttributeValue;
                  }
                  $iColumn++;
                }
              } else {
                print "$attribute is a ARRAY\n";
              }
            } elsif ( ref($value) eq '' || ref($value) eq 'JSON::PP::Boolean' ) {
              $tmp->{tabular}->{"tabular.$attribute"} = $value;
            } else {
              print "For $attribute, ref is '".ref($value)."'\n";
            }
          }
        }


        #delete($tmp->{signatures}->{"bdqc.builtin.tabular"});
        $qckb->{files}->{$fileTag}->{signatures} = $tmp;
        $iFile++;
        #last if ( $iFile > 300 );
      }

      $self->setIsChanged(1);

    } else {
      $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"ImportFileCannotBeOpened", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
        message=>"Input file '$inputFile' exists but cannot be opened.");
    }
    
  } else {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"ImportFileDoesNotExist", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
      message=>"Input file '$inputFile' does not exist.");
  }


  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub loadKb {
###############################################################################
# loadKb
###############################################################################
  my $METHOD = 'loadKb';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  my $kbRootPath = processParameters( name=>'kbRootPath', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  if ( ! defined($kbRootPath) ) {
    $kbRootPath = $self->getKbRootPath();
  } else {
    $self->setKbRootPath($kbRootPath);
  }

  if ( ! defined($kbRootPath) ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>'AttributekbRootPathNotDefined', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
       message=>"Attribute 'kbRootPath' must be defined");
    print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
    return $response;
  }

  my $skipIfFileNotFound = processParameters( name=>'skipIfFileNotFound', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  use Storable;

  $kbRootPath = $self->getKbRootPath();
  my $filename = "$kbRootPath.qckb.storable";

  #### Make sure the file exists
  if ( -e $filename ) {
    $response->logEvent( level=>'INFO', minimumVerbosity=>0, verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
      message=>"Loading BDQC KB from '$filename'");
    my $qckb =  retrieve($filename);
    $self->setQckb($qckb);
    $self->setIsChanged(0);

  } else {
    if ( $skipIfFileNotFound ) {
	  $response->setState( status=>'OK', message=>"Skipping IfFileNotFound as requested");
	  $response->{fileNotFound} = 1;
	} else {
      $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"DatastoreDoesNotExist", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
        message=>"Datastore '$filename' does not exist.");
    }
  }

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub saveKb {
###############################################################################
# saveKb
###############################################################################
  my $METHOD = 'saveKb';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  my $kbRootPath = processParameters( name=>'kbRootPath', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  if ( ! defined($kbRootPath) ) {
    $kbRootPath = $self->getKbRootPath();
  } else {
    $self->setKbRootPath($kbRootPath);
  }

  if ( ! defined($kbRootPath) ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>'AttributekbRootPathNotDefined', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
       message=>"Attribute 'kbRootPath' must be defined");
    print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
    return $response;
  }

  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  use Storable;

  my $qckb = $self->getQckb();
  $kbRootPath = $self->getKbRootPath();

  unless ( $self->getIsChanged() ) {
    $response->logEvent( level=>'INFO', minimumVerbosity=>0, message=>"BDQC KB has not changed. No need to save.", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
    $response->setState( status=>'OK', message=>"No changes in the KB. No need to save.");
    print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
    return $response;
  }

  my $filename = "$kbRootPath.qckb.storable";
  $response->logEvent( level=>'INFO', minimumVerbosity=>0, message=>"Saving BDQC KB to '$filename' and .json", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );

  store($qckb,$filename);
  $self->setIsChanged(0);

  use JSON;
  my $json = JSON->new->allow_nonref;
  my $buffer = $json->pretty->encode($qckb);
  $filename = "$kbRootPath.qckb.json";
  open(OUTFILE,">$filename");
  print OUTFILE $buffer;
  close(OUTFILE);

  $response->logEvent( level=>'INFO', minimumVerbosity=>0, message=>"BDQC KB saved", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub scanDataPath {
###############################################################################
# scanDataPath
###############################################################################
  my $METHOD = 'scanDataPath';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  my $dataDirectory = processParameters( name=>'dataDirectory', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  if ( ! defined($dataDirectory) ) {
    $dataDirectory = $self->getDataDirectory();
  } else {
    $self->setDataDirectory($dataDirectory);
  }

  if ( ! defined($dataDirectory) ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>'AttributedataDirectoryNotDefined', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
       message=>"Attribute 'dataDirectory' must be defined");
    print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
    return $response;
  }

  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  my $qckb = $self->getQckb();
  $self->setIsChanged(1);

  #### If the dataDirectory was a Windows path, fix it
  if ( $dataDirectory =~ /\\/ ) {
    $dataDirectory =~ s/\\/\//g;
    $self->setDataDirectory($dataDirectory);
  }

  my %stats = ( totalFiles=>0, newFiles=>0, totalSize=>0 );

  #### Verify that the specified directory exists and is a directory
  if ( ! -e $dataDirectory ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>'DataDirecoryNotFound', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
      message=>"Data directory '$dataDirectory' is not found");
    return $response;
  } elsif ( ! -d $dataDirectory ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>'SpecifiedDataDirecoryNotADirectory', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
      message=>"Data directory '$dataDirectory' is  found but is not a directory");
    return $response;
  }

  #### See if this dataDirectory has already been scanned
  my $dataDirectoryId = '';
  my $nPreviousDirectories = scalar(@{$qckb->{dataDirectories}});
  foreach my $previousDirectories ( @{$qckb->{dataDirectories}} ) {
    if ( $previousDirectories->{path} eq $dataDirectory ) {
	  $dataDirectoryId = $previousDirectories->{id};
	}
  }

  #### If we haven't scanned this one before, add this path now
  unless ( $dataDirectoryId ) {
    $nPreviousDirectories++;
    $dataDirectoryId = "dir$nPreviousDirectories";
    push(@{$qckb->{dataDirectories}}, { id=>$dataDirectoryId, path=>$dataDirectory });
  }

  #### Put this directory on the stack and recursively catalog all files}
  my @directoriesToProcess = ( $dataDirectory );
  my $done = 0;
  while ( ! $done ) {
    my $directory = shift(@directoriesToProcess);
	last unless ( $directory );
	opendir(DIR,$directory) || die("ERROR: Unable to open directory '$directory'");
	my @entries = grep(!/^\.{1,2}$/, readdir(DIR));
	closedir(DIR);
	@entries = sort(@entries);
	foreach my $entry ( @entries ) {
	  if ( -f "$directory/$entry" ) {
	    my $fileTag = "$dataDirectoryId:$directory/$entry";
	    my $filePath = "$directory/$entry";
        $stats{totalFiles}++;

        #### Parse the filename into pieces
        my @parts = split(/\./,$entry);
        my $nParts = scalar(@parts);
        my $basename = '';
        my $extension = '';
        my $uncompressedExtension = '';
        my $isCompressed = 0;
        if ( $nParts == 1) {
          $basename = $entry;
        } else {
          $extension = $parts[$nParts-1];
          my %compressedExtensions = ( gz=>1, zip=>1, bz2=>1 );
          if ( $compressedExtensions{$extension} ) {
            $isCompressed = 1;
            if ( $nParts == 2 ) {
              $basename = $parts[0];
            } else {
              $uncompressedExtension = $parts[$nParts-2];
              $basename = join(".",@parts[0..$nParts-3]);
            }
          } else {
            $uncompressedExtension = $extension;
            $basename = join(".",@parts[0..$nParts-2]);
          }
        }

	    my $tracking = { fileTag=>$fileTag, filePath=>$filePath, filename=>$entry, dataDirectory=>$dataDirectory, dataDirectoryId=>$dataDirectoryId };
		my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat($filePath);
        $size = 0 if ( ! defined($size) );
        $mtime = 0 if ( ! defined($mtime) );
        $mode = 0 if ( ! defined($mode) );
        $stats{totalSize} += $size;

		if ( exists($qckb->{files}->{$fileTag}) ) {
		  $tracking->{isNew} = 0;
		  $qckb->{files}->{$fileTag} ->{signatures}->{tracking}->{isNew} = 0;
          if ( $mtime ne $qckb->{files}->{$fileTag}->{signatures}->{extrinsic}->{mtime} ) {
            $qckb->{files}->{$fileTag} ->{signatures}->{tracking}->{isChanged} = 1;
          }
		} else {
		  $tracking->{isNew} = 1;
          $stats{newFiles}++;
		  $qckb->{files}->{$fileTag} ->{signatures}->{tracking} = $tracking;
          my $extrinsic = { filename=>$entry, mtime=>$mtime, size=>$size, mode=>$mode, extension=>$extension, iscompressed=>$isCompressed, uncompressedExtension=>$uncompressedExtension, basename=>$basename };
          $qckb->{files}->{$fileTag}->{signatures}->{extrinsic} = $extrinsic;
		}
	  } elsif ( -d "$directory/$entry" ) {
	    push(@directoriesToProcess,"$directory/$entry");
	  } else {
	    print "Do not know what to do with $directory/$entry\n";
	  }
	}
  }

  $response->{stats} = \%stats;
  $response->logEvent( level=>'INFO', minimumVerbosity=>0, message=>"$stats{totalFiles} files ($stats{totalSize} bytes) scanned. $stats{newFiles} files are new to this scan.", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub show {
###############################################################################
# show
###############################################################################
  my $METHOD = 'show';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Create a simple text representation of the data in the object
  my $buffer = '';
  $buffer .= "$self\n";
  my $dataDirectory = $self->getDataDirectory() || '';
  $buffer .= "  dataDirectory=$dataDirectory\n";
  my $isChanged = $self->getIsChanged() || '';
  $buffer .= "  isChanged=$isChanged\n";
  my $kbRootPath = $self->getKbRootPath() || '';
  $buffer .= "  kbRootPath=$kbRootPath\n";
  my $qckb = $self->getQckb() || '';
  $buffer .= "  qckb=$qckb\n";

  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return $buffer;
}


sub splitFilePath {
###############################################################################
# splitFilePath
###############################################################################
  my $METHOD = 'splitFilePath';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my $filePath = shift;

  my %components;

  #### Parse off the directory
  my @pathParts = split(/\//,$filePath);
  my $directory = join("\/",@pathParts[0..($#pathParts-1)]);
  my $entry = $pathParts[$#pathParts];

  #### Parse the filename into pieces
  my @parts = split(/\./,$entry);
  my $nParts = scalar(@parts);
  my $basename = '';
  my $extension = '';
  my $uncompressedExtension = '';
  my $isCompressed = 0;
  if ( $nParts == 1) {
    $basename = $entry;
  } else {
    $extension = $parts[$nParts-1];
    my %compressedExtensions = ( gz=>1, zip=>1, bz2=>1 );
    if ( $compressedExtensions{$extension} ) {
      $isCompressed = 1;
      if ( $nParts == 2 ) {
        $basename = $parts[0];
      } else {
        $uncompressedExtension = $parts[$nParts-2];
        $basename = join(".",@parts[0..$nParts-3]);
      }
    } else {
      $uncompressedExtension = $extension;
      $basename = join(".",@parts[0..$nParts-2]);
    }
  }

  my $components = { directory=>$directory, basename=>$basename, extension=>$extension, uncompressedExtension=>$uncompressedExtension,
    isCompressed=>$isCompressed, filename=>$entry };

  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return $components;
}

###############################################################################
1;
