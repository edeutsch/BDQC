package BDQC::KB;

###############################################################################
# Class       : BDQC::KB
#
# Description : This class is autogenerated via OOAPI and is..
#
###############################################################################

use strict;
use warnings;

use BDQC::Response qw(processParameters);

my $CLASS = 'BDQC::KB';
my $DEBUG = 0;
my $VERBOSE = 0;
my $TESTONLY = 0;

my $VERSION = '0.0.1';


sub new {
###############################################################################
# Constructor
###############################################################################
  my $METHOD = 'new';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift;
  my %parameters = @_;
  my $class = ref($self) || $self;

  #### Create the object with any default attributes
  $self = {
  };
  bless $self => $class;

  #### Initialize class variables the first time the class is used
  # none

  #### Process constructor argument class variables
  # none

  #### Process constructor object parameters
  my $dataDirectory = processParameters( name=>'dataDirectory', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD );
  $self->{_dataDirectory} = $dataDirectory;
  my $isChanged = processParameters( name=>'isChanged', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD );
  $self->{_isChanged} = $isChanged;
  my $kbRootPath = processParameters( name=>'kbRootPath', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD );
  $self->{_kbRootPath} = $kbRootPath;
  my $qckb = processParameters( name=>'qckb', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD );
  $self->{_qckb} = $qckb;

  #### Complain about any unexpected parameters
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return($self);
}


sub getDataDirectory {
###############################################################################
# getDataDirectory
###############################################################################
  my $METHOD = 'getDataDirectory';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");

  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return($self->{_dataDirectory});
}


sub setDataDirectory {
###############################################################################
# setDataDirectory
###############################################################################
  my $METHOD = 'setDataDirectory';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");
  my $value = shift;


  $self->{_dataDirectory} = $value;
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return 1;
}


sub getIsChanged {
###############################################################################
# getIsChanged
###############################################################################
  my $METHOD = 'getIsChanged';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");

  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return($self->{_isChanged});
}


sub setIsChanged {
###############################################################################
# setIsChanged
###############################################################################
  my $METHOD = 'setIsChanged';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");
  my $value = shift;

  #### Ensure that the value is of type int32
  unless ( $value =~ /^s*[\-\+]*\d+\s*$/ ) {
    print "ERROR: Unable to set isChanged to '$value': not valid int32\n";
  }


  $self->{_isChanged} = $value;
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return 1;
}


sub getKbRootPath {
###############################################################################
# getKbRootPath
###############################################################################
  my $METHOD = 'getKbRootPath';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");

  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return($self->{_kbRootPath});
}


sub setKbRootPath {
###############################################################################
# setKbRootPath
###############################################################################
  my $METHOD = 'setKbRootPath';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");
  my $value = shift;


  $self->{_kbRootPath} = $value;
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return 1;
}


sub getQckb {
###############################################################################
# getQckb
###############################################################################
  my $METHOD = 'getQckb';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");

  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return($self->{_qckb});
}


sub setQckb {
###############################################################################
# setQckb
###############################################################################
  my $METHOD = 'setQckb';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die("parameter self not passed");
  my $value = shift;


  $self->{_qckb} = $value;
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return 1;
}


sub calcModels {
###############################################################################
# calcModels
###############################################################################
  my $METHOD = 'calcModels';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  my $qckb = $self->getQckb();
  $self->setIsChanged(1);
  use BDQC::VectorModel;
  use BDQC::HistogramModel;

  #### For each fileType, signature, and attribute, build a model of the observed data
  foreach my $fileType ( keys(%{$qckb->{fileTypes}}) ) {
    foreach my $signature ( keys(%{$qckb->{fileTypes}->{$fileType}->{signatures}}) ) {
      foreach my $attribute ( keys(%{$qckb->{fileTypes}->{$fileType}->{signatures}->{$signature}}) ) {
        my $values = $qckb->{fileTypes}->{$fileType}->{signatures}->{$signature}->{$attribute}->{values};
        my $model;
        if ( $values->[0] && $values->[0] =~ /^HASH\(/ ) {
          $model = BDQC::HistogramModel->new( histograms=>$values );
        } else {
         #print "$signature.$attribute: ".join(",",@{$values})."\n";
          $model = BDQC::VectorModel->new( vector=>$values );
        }
        my $result = $model->create();
        if ( $result->{status} eq 'OK' ) {
          $qckb->{fileTypes}->{$fileType}->{signatures}->{$signature}->{$attribute}->{model} = $result->{model};
        } else {
          $response->mergeResponse( responseToMerge=>$result );
        }
      }
    }
  }

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub calcSignatures {
###############################################################################
# calcSignatures
###############################################################################
  my $METHOD = 'calcSignatures';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  my $qckb = $self->getQckb();
  $self->setIsChanged(1);

  use BDQC::FileSignature::Text;
  use BDQC::FileSignature::Binary;

  my %knownExtensions = (
    "tsv" => { specificTypeName=>'tsv', genericType=>'tabular', signatureList=>[ "FileSignature::Tabular" ] },
    "fasta" => { specificTypeName=>'FASTA', genericType=>'text', signatureList=>[ "FileSignature::Text" ] },
    "qlog" => { specificTypeName=>'qlog', genericType=>'text', signatureList=>[ "FileSignature::Text" ] },
    "xml" => { specificTypeName=>'xml', genericType=>'xml', signatureList=>[ "FileSignature::XML" ] },
    "jpg" => { specificTypeName=>'jpg', genericType=>'image', signatureList=>[ "FileSignature::Binary" ] },
    "jpeg" => { specificTypeName=>'jpg', genericType=>'image', signatureList=>[ "FileSignature::Binary" ] },
    "JPG" => { specificTypeName=>'jpg', genericType=>'image', signatureList=>[ "FileSignature::Binary" ] },
    "JPEG" => { specificTypeName=>'jpg', genericType=>'image', signatureList=>[ "FileSignature::Binary" ] },
    "raw" => { specificTypeName=>'raw', genericType=>'binary', signatureList=>[ "FileSignature::Binary" ] },
    "RAW" => { specificTypeName=>'raw', genericType=>'binary', signatureList=>[ "FileSignature::Binary" ] },
  );

  my $nFiles = 0;

  foreach my $fileTag ( keys(%{$qckb->{files}}) ) {
    $nFiles++;
    my $signatures = $qckb->{files}->{$fileTag}->{signatures};
    my $filePath = $signatures->{tracking}->{filePath};
    if ( $signatures->{extrinsic}->{isCompressed} ) {
      $filePath = "zcat $filePath |";   #FIXME
    }
    my $knownExtension = $knownExtensions{$signatures->{extrinsic}->{uncompressedExtension}};
    my $signatureList;
    my $fileTypeName = $signatures->{extrinsic}->{uncompressedExtension};
    if ( $knownExtension ) {
      $signatureList = $knownExtension->{signatureList};
      $fileTypeName = $knownExtension->{specificTypeName};
    } else {
      #$signatureList = [ 'FileSignature::UnknownFiletype' ];
      $signatureList = [ 'FileSignature::Text' ];
    }
    $signatures->{fileType}->{typeName} = $fileTypeName;

    foreach my $signatureName ( @{$signatureList} ) {
      my $moduleName = "BDQC::$signatureName";
      my $signature = $moduleName->new( filePath=>$filePath );
      my $result = $signature->calcSignature();
      if ( $result->{status} eq 'OK' ) {
        $signatures->{$signatureName} = $result->{signature};
      } else {
        $response->mergeResponse( sourceResponse=>$result );
        return $response;
      }
    }

  }

  $response->logEvent( level=>'INFO', minimumVerbosity=>0, message=>"Calculated signatures for $nFiles files", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub collateData {
###############################################################################
# collateData
###############################################################################
  my $METHOD = 'collateData';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  my $qckb = $self->getQckb();
  $self->setIsChanged(1);

  my $nFiles = 0;

  #### First scan through all the files and assign them to a fileType. Models will be built within fileTypes
  foreach my $fileTag ( keys(%{$qckb->{files}}) ) {
    $nFiles++;
    my $signatures = $qckb->{files}->{$fileTag}->{signatures};
    my $fileTag = $signatures->{tracking}->{fileTag};
    my $fileTypeName = $signatures->{fileType}->{typeName};

    unless ( $qckb->{fileTypes}->{$fileTypeName} ) {
      $qckb->{fileTypes}->{$fileTypeName} = { name=>$fileTypeName, fileTagList=>[], signatures=>{} };
    }

    if ( $signatures->{tracking}->{isNew} ) {
      push(@{$qckb->{fileTypes}->{$fileTypeName}->{fileTagList}},$fileTag);
    }
  }

  #### For each fileType, extract all the signatures for which we'll make a model
  foreach my $fileType ( keys(%{$qckb->{fileTypes}}) ) {
    my $signatures = $qckb->{fileTypes}->{$fileType}->{signatures};
    foreach my $fileTag ( @{$qckb->{fileTypes}->{$fileType}->{fileTagList}} ) {
      foreach my $signature ( keys(%{$qckb->{files}->{$fileTag}->{signatures}}) ) {
        foreach my $attribute ( keys(%{$qckb->{files}->{$fileTag}->{signatures}->{$signature}}) ) {
          unless ( $signatures->{$signature}->{$attribute}->{values} ) {
            $signatures->{$signature}->{$attribute}->{values} = [];
          }
          push(@{$signatures->{$signature}->{$attribute}->{values}},$qckb->{files}->{$fileTag}->{signatures}->{$signature}->{$attribute});
        }
      }
    }
  }

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub createKb {
###############################################################################
# createKb
###############################################################################
  my $METHOD = 'createKb';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;

  #### Create the qckb data structure and fill it with basic information
  my $qckb = {};
  $self->setQckb($qckb);
  $qckb->{type} = "BDQC";
  $self->setIsChanged(1);

  my ($sec,$min,$hour,$mday,$mon,$year) = localtime();
  $qckb->{startDate} = sprintf("%d-%d-%d %d:%d:%d",1900+$year,$mon+1,$mday,$hour,$min,$sec);

  #### Empty array for updates
  $qckb->{updates} = [];
  $qckb->{changeLog} = [];
  $qckb->{dataDirectories} = [];

  $qckb->{files} = {};
  $qckb->{filetypes} = {};
  $qckb->{models} = [];

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub getOutliers {
###############################################################################
# getOutliers
###############################################################################
  my $METHOD = 'getOutliers';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  my $qckb = $self->getQckb();
  my @outlierValues;

  #### For each fileType, signature, and attribute, record if any deviations are outliers
  foreach my $fileType ( keys(%{$qckb->{fileTypes}}) ) {
    foreach my $signature ( keys(%{$qckb->{fileTypes}->{$fileType}->{signatures}}) ) {
      foreach my $attribute ( keys(%{$qckb->{fileTypes}->{$fileType}->{signatures}->{$signature}}) ) {
        my $values = $qckb->{fileTypes}->{$fileType}->{signatures}->{$signature}->{$attribute}->{values};
        my $model = $qckb->{fileTypes}->{$fileType}->{signatures}->{$signature}->{$attribute}->{model};
        foreach my $deviation ( @{$model->{deviations}} ) {
          if ( defined($deviation->{deviationFlag}) && $deviation->{deviationFlag} eq 'outlier' ) {
            #print "$signature.$attribute:\n";
            my $value = '(null)';
            $value = $deviation->{value} if ( defined($deviation->{value}) );
            #print "  Value $value is an outlier with a deviation of $deviation->{deviation}\n";
            push(@outlierValues,{ signature=>$signature, attribute=>$attribute, value=>$deviation->{value}, deviation=>$deviation });
          }
        }
      }
    }
  }

  #### For each outlier value, find the files that are the outliers
  my %outlierFiles;
  foreach my $fileTag ( keys(%{$qckb->{files}}) ) {
    my $signatures = $qckb->{files}->{$fileTag}->{signatures};
    foreach my $outlier ( @outlierValues ) {
      my $signature = $outlier->{signature};
      my $attribute = $outlier->{attribute};
      my $value = $outlier->{value};
      my $thisIsAnOutlier = 0;
      if ( $signatures->{$signature} && exists($signatures->{$signature}->{$attribute}) ) {
        if ( defined($value) ) {
          if ( defined($signatures->{$signature}->{$attribute}) ) {
            if ( $value eq $signatures->{$signature}->{$attribute} ) {
              $thisIsAnOutlier = 1;
            } else {
              # this is not an outlier
            }
          } else {
            # this is not an outlier
          }
        } else {
          if ( defined($signatures->{$signature}->{$attribute}) ) {
            # this is not an outlier
          } else {
            $thisIsAnOutlier = 1;
          }
        }
      }

      #### If this is an outlier, record it
      if ( $thisIsAnOutlier ) {
        unless ( $outlierFiles{$fileTag} ) {
          $outlierFiles{$fileTag} = [];
        }
        push(@{$outlierFiles{$fileTag}},$outlier);
      }

    } # end foreach $outlier
  } # end foreach $fileTag


  #### Print out the outlier files and their problems
  foreach my $outlierFile ( sort keys(%outlierFiles) ) {
    print "$outlierFile is an outlier because:\n";
    foreach my $outlier ( @{$outlierFiles{$outlierFile}} ) {
      my $signature = $outlier->{signature};
      my $attribute = $outlier->{attribute};
      my $value = $outlier->{value};
      $value = '(null)' if ( ! defined($value) );
      print "  $signature.$attribute: Value $value is an outlier\n";
    }
  }

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub loadKb {
###############################################################################
# loadKb
###############################################################################
  my $METHOD = 'loadKb';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  my $kbRootPath = processParameters( name=>'kbRootPath', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  if ( ! defined($kbRootPath) ) {
    $kbRootPath = $self->getKbRootPath();
  } else {
    $self->setKbRootPath($kbRootPath);
  }

  if ( ! defined($kbRootPath) ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>'AttributekbRootPathNotDefined', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
       message=>"Attribute 'kbRootPath' must be defined");
    print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
    return $response;
  }

  my $skipIfFileNotFound = processParameters( name=>'skipIfFileNotFound', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  use Storable;

  $kbRootPath = $self->getKbRootPath();
  my $filename = "$kbRootPath.qckb.storable";

  #### Make sure the file exists
  if ( -e $filename ) {
    $response->logEvent( level=>'INFO', minimumVerbosity=>0, verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
      message=>"Loading BDQC KB from '$filename'.");
    my $qckb =  retrieve($filename);
    $self->setQckb($qckb);
    $self->setIsChanged(0);

  } else {
    if ( $skipIfFileNotFound ) {
	  $response->setState( status=>'OK', message=>"Skipping IfFileNotFound as requested");
	  $response->{fileNotFound} = 1;
	} else {
      $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"DatastoreDoesNotExist", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
        message=>"Datastore '$filename' does not exist.");
    }
  }

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub saveKb {
###############################################################################
# saveKb
###############################################################################
  my $METHOD = 'saveKb';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  my $kbRootPath = processParameters( name=>'kbRootPath', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  if ( ! defined($kbRootPath) ) {
    $kbRootPath = $self->getKbRootPath();
  } else {
    $self->setKbRootPath($kbRootPath);
  }

  if ( ! defined($kbRootPath) ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>'AttributekbRootPathNotDefined', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
       message=>"Attribute 'kbRootPath' must be defined");
    print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
    return $response;
  }

  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  use Storable;

  my $qckb = $self->getQckb();
  $kbRootPath = $self->getKbRootPath();

  unless ( $self->getIsChanged() ) {
    $response->logEvent( level=>'INFO', minimumVerbosity=>0, message=>"BDQC KB has not changed. No need to save.", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
    $response->setState( status=>'OK', message=>"No changes in the KB. No need to save.");
    print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
    return $response;
  }

  my $filename = "$kbRootPath.qckb.storable";
  store($qckb,$filename);
  $self->setIsChanged(0);

  use JSON;
  my $json = JSON->new->allow_nonref;
  my $buffer = $json->pretty->encode($qckb);
  $filename = "$kbRootPath.qckb.json";
  open(OUTFILE,">$filename");
  print OUTFILE $buffer;
  close(OUTFILE);

  $response->logEvent( level=>'INFO', minimumVerbosity=>0, message=>"BDQC KB saved to '$filename'.", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub scanDataPath {
###############################################################################
# scanDataPath
###############################################################################
  my $METHOD = 'scanDataPath';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Define standard parameters
  my ( $response, $debug, $verbose, $quiet, $testonly, $outputDestination, $rmiServer );

  {
  #### Set up a response object
  $response = BDQC::Response->new();
  $response->setState( status=>'NOTSET', message=>"Status not set in method $METHOD");

  #### Process standard parameters
  $debug = processParameters( name=>'debug', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$DEBUG, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $verbose = processParameters( name=>'verbose', required=>0, allowUndef=>0, default=>0, overrideIfFalse=>$VERBOSE, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $quiet = processParameters( name=>'quiet', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $testonly = processParameters( name=>'testonly', required=>0, allowUndef=>0, default=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $outputDestination = processParameters( name=>'outputDestination', required=>0, allowUndef=>0, default=>'STDERR', parameters=>\%parameters, caller=>$METHOD, response=>$response );
  $rmiServer = processParameters( name=>'rmiServer', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $debug && !$DEBUG );
  }
  #### Process specific parameters
  my $dataDirectory = processParameters( name=>'dataDirectory', required=>0, allowUndef=>0, parameters=>\%parameters, caller=>$METHOD, response=>$response );
  if ( ! defined($dataDirectory) ) {
    $dataDirectory = $self->getDataDirectory();
  } else {
    $self->setDataDirectory($dataDirectory);
  }

  if ( ! defined($dataDirectory) ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>'AttributedataDirectoryNotDefined', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
       message=>"Attribute 'dataDirectory' must be defined");
    print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
    return $response;
  }

  #### Die if any unexpected parameters are passed
  my $unexpectedParameters = '';
  foreach my $parameter ( keys(%parameters) ) { $unexpectedParameters .= "ERROR: unexpected parameter '$parameter'\n"; }
  die("CALLING ERROR [$METHOD]: $unexpectedParameters") if ($unexpectedParameters);

  #### Return if there was a problem with the required parameters
  return $response if ( $response->{errorCode} =~ /MissingParameter/i );

  #### Set the default state to not implemented. Do not change this. Override later
  my $isImplemented = 0;

  #### BEGIN CUSTOMIZATION. DO NOT EDIT MANUALLY ABOVE THIS. EDIT MANUALLY ONLY BELOW THIS.

  $isImplemented = 1;
  my $qckb = $self->getQckb();
  $self->setIsChanged(1);

  #### If the dataDirectory was a Windows path, fix it
  if ( $dataDirectory =~ /\\/ ) {
    $dataDirectory =~ s/\\/\//g;
    $self->setDataDirectory($dataDirectory);
  }

  my %stats = ( totalFiles=>0, newFiles=>0, totalSize=>0 );

  #### Verify that the specified directory exists and is a directory
  if ( ! -e $dataDirectory ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>'DataDirecoryNotFound', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
      message=>"Data directory '$dataDirectory' is not found");
    return $response;
  } elsif ( ! -d $dataDirectory ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>'SpecifiedDataDirecoryNotADirectory', verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination, 
      message=>"Data directory '$dataDirectory' is  found but is not a directory");
    return $response;
  }

  #### See if this dataDirectory has already been scanned
  my $dataDirectoryId = '';
  my $nPreviousDirectories = scalar(@{$qckb->{dataDirectories}});
  foreach my $previousDirectories ( @{$qckb->{dataDirectories}} ) {
    if ( $previousDirectories->{path} eq $dataDirectory ) {
	  $dataDirectoryId = $previousDirectories->{id};
	}
  }

  #### If we haven't scanned this one before, add this path now
  unless ( $dataDirectoryId ) {
    $nPreviousDirectories++;
    $dataDirectoryId = "dir$nPreviousDirectories";
    push(@{$qckb->{dataDirectories}}, { id=>$dataDirectoryId, path=>$dataDirectory });
  }

  #### Put this directory on the stack and recursively catalog all files}
  my @directoriesToProcess = ( $dataDirectory );
  my $done = 0;
  while ( ! $done ) {
    my $directory = shift(@directoriesToProcess);
	last unless ( $directory );
	opendir(DIR,$directory) || die("ERROR: Unable to open directory '$directory'");
	my @entries = grep(!/^\.{1,2}$/, readdir(DIR));
	closedir(DIR);
	@entries = sort(@entries);
	foreach my $entry ( @entries ) {
	  if ( -f "$directory/$entry" ) {
	    my $fileTag = "$dataDirectoryId:$directory/$entry";
	    my $filePath = "$directory/$entry";
        $stats{totalFiles}++;

        #### Parse the filename into pieces
        my @parts = split(/\./,$entry);
        my $nParts = scalar(@parts);
        my $basename = '';
        my $extension = '';
        my $uncompressedExtension = '';
        my $isCompressed = 0;
        if ( $nParts == 1) {
          $basename = $entry;
        } else {
          $extension = $parts[$nParts-1];
          my %compressedExtensions = ( gz=>1, zip=>1, bz2=>1 );
          if ( $compressedExtensions{$extension} ) {
            $isCompressed = 1;
            if ( $nParts == 2 ) {
              $basename = $parts[0];
            } else {
              $uncompressedExtension = $parts[$nParts-2];
              $basename = join(".",@parts[0..$nParts-3]);
            }
          } else {
            $uncompressedExtension = $extension;
            $basename = join(".",@parts[0..$nParts-2]);
          }
        }

	    my $tracking = { fileTag=>$fileTag, filePath=>$filePath, filename=>$entry, dataDirectory=>$dataDirectory, dataDirectoryId=>$dataDirectoryId };
		my ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,$atime,$mtime,$ctime,$blksize,$blocks) = stat($filePath);
        $size = 0 if ( ! defined($size) );
        $mtime = 0 if ( ! defined($mtime) );
        $mode = 0 if ( ! defined($mode) );
        $stats{totalSize} += $size;

		if ( exists($qckb->{files}->{$fileTag}) ) {
		  $tracking->{isNew} = 0;
		  $qckb->{files}->{$fileTag} ->{signatures}->{tracking}->{isNew} = 0;
          if ( $mtime ne $qckb->{files}->{$fileTag}->{signatures}->{extrinsic}->{mtime} ) {
            $qckb->{files}->{$fileTag} ->{signatures}->{tracking}->{isChanged} = 1;
          }
		} else {
		  $tracking->{isNew} = 1;
          $stats{newFiles}++;
		  $qckb->{files}->{$fileTag} ->{signatures}->{tracking} = $tracking;
          my $extrinsic = { filename=>$entry, mtime=>$mtime, size=>$size, mode=>$mode, extension=>$extension, iscompressed=>$isCompressed, uncompressedExtension=>$uncompressedExtension, basename=>$basename };
          $qckb->{files}->{$fileTag}->{signatures}->{extrinsic} = $extrinsic;
		}
	  } elsif ( -d "$directory/$entry" ) {
	    push(@directoriesToProcess,"$directory/$entry");
	  } else {
	    print "Do not know what to do with $directory/$entry\n";
	  }
	}
  }

  $response->{stats} = \%stats;
  $response->logEvent( level=>'INFO', minimumVerbosity=>0, message=>"$stats{totalFiles} files ($stats{totalSize} bytes) scanned. $stats{newFiles} files are new to this scan.", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );

  #### END CUSTOMIZATION. DO NOT EDIT MANUALLY BELOW THIS. EDIT MANUALLY ONLY ABOVE THIS.
  {
  if ( ! $isImplemented ) {
    $response->logEvent( status=>'ERROR', level=>'ERROR', errorCode=>"Method${METHOD}NotImplemented", message=>"Method $METHOD has not yet be implemented", verbose=>$verbose, debug=>$debug, quiet=>$quiet, outputDestination=>$outputDestination );
  }

  #### Update the status codes and return
  $response->setState( status=>'OK', message=>"Method $METHOD completed normally") if ( $response->{status} eq 'NOTSET' );
  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $debug );
  }
  return $response;
}


sub show {
###############################################################################
# show
###############################################################################
  my $METHOD = 'show';
  print "DEBUG: Entering $CLASS.$METHOD\n" if ( $DEBUG );
  my $self = shift || die ("self not passed");
  my %parameters = @_;

  #### Create a simple text representation of the data in the object
  my $buffer = '';
  $buffer .= "$self\n";
  my $dataDirectory = $self->getDataDirectory() || '';
  $buffer .= "  dataDirectory=$dataDirectory\n";
  my $isChanged = $self->getIsChanged() || '';
  $buffer .= "  isChanged=$isChanged\n";
  my $kbRootPath = $self->getKbRootPath() || '';
  $buffer .= "  kbRootPath=$kbRootPath\n";
  my $qckb = $self->getQckb() || '';
  $buffer .= "  qckb=$qckb\n";

  print "DEBUG: Exiting $CLASS.$METHOD\n" if ( $DEBUG );
  return $buffer;
}



###############################################################################
1;
